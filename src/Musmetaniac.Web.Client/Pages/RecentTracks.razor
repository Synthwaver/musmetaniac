@using Musmetaniac.Web.Common.Models
@using System.Threading

@page "/recenttracks"

@implements IDisposable

@inject IRecurringJobFactory _recurringJobFactory
@inject IMusmetaniacApiRequestMessageProvider _musmetaniacApiRequestMessageProvider
@inject NavigationManager _navigation
@inject HttpClient _httpClient

<PageTitle>Recent tracks</PageTitle>

<Card>
    <TitleTemplate>
        <Title Level="3">Recent Tracks</Title>
    </TitleTemplate>
    <Body>
        <Space Direction="DirectionVHType.Vertical" Style="display: unset;">
            <SpaceItem style="display: flex; gap: 5px;">
                <Input Id="username" Placeholder="Username" @bind-Value="@InsertedUsername" Size="@InputSize.Large" AllowClear />
                <Button
                    Type="@ButtonType.Primary"
                    Icon="@(_isRecentTracksFirstRequestSuccessful ? IconType.Outline.Reload : IconType.Outline.ArrowRight)"
                    OnClick="@HandleRefreshClickAsync"
                    Size="@InputSize.Large"
                >
                </Button>
            </SpaceItem>
            @if (!_errorMessage.IsNullOrEmpty())
            {
                <SpaceItem>
                    <Alert Message="@_errorMessage" Type="@AlertType.Error" />
                </SpaceItem>
            }
            <SpaceItem>
                Limit
                <Select
                    TItem="int"
                    TItemValue="int"
                    DataSource="new[] { 5, 10, 15 }"
                    Value="@_trackLimit"
                    ValueChanged="v => HandleLimitChange(v)"
                    Size="@InputSize.Small"
                    Style="width: 60px;"
                >
                </Select>
            </SpaceItem>
        </Space>
    </Body>
</Card>

@if (_recentTracks.Count != 0)
{
    <Title Level="4" Style="margin-top: 20px; margin-bottom: 20px;">
        Recent Tracks for <Text Code>@_username</Text>
    </Title>
    @foreach (var track in _recentTracks.Take(_trackLimit))
    {
        <RecentTrack Track="@track" />
    }
}

@code {
    private readonly TimeSpan _pollingPeriod = TimeSpan.FromSeconds(5);

    private List<RecentTracksModel.Track> _recentTracks = new();
    private RecurringJob _recentTracksPollingJob = null!;
    private CancellationTokenSource? _recentTracksFirstRequestCancellationTokenSource;
    private bool _isRecentTracksFirstRequestSuccessful;
    private string _insertedUsername = "";
    private string _username = "";
    private int _trackLimit = 5;
    private string? _errorMessage;

    [Parameter]
    [SupplyParameterFromQuery(Name = "username")]
    public string InsertedUsername
    {
        get => _insertedUsername;
        set
        {
            if (_insertedUsername == value)
                return;

            _insertedUsername = value;
            _navigation.UpdateQueryParameter("username", value);
        }
    }

    public void Dispose()
    {
        _recentTracksPollingJob.Dispose();
        CancelRecentTracksFirstRequestAndDisposeTokenSource();
        GC.SuppressFinalize(this);
    }

    protected override void OnInitialized()
    {
        _recentTracksPollingJob = _recurringJobFactory.CreateRecurringJob(RefreshRecentTracks, _pollingPeriod);

        Task RefreshRecentTracks(CancellationToken cancellationToken) => _httpClient.SendRequestAsync<RecentTracksModel>(GetRecentTracksRequestMessage,
            successCallback: model =>
            {
                // The track playing now is temporary and is updated with each request.
                // Since it may stop playing and disappear from the list, we always store one more track
                // to display tracks according to the selected limit.
                _recentTracks.RemoveAll(t => t.IsPlayingNow);
                _recentTracks = model.Tracks.Concat(_recentTracks).Take(_trackLimit + 1).ToList();
                StateHasChanged();
            },
            cancellationToken: cancellationToken);
    }

    private void HandleLimitChange(int value)
    {
        var shouldResumePolling = _recentTracksPollingJob.IsStarted;
        _recentTracksPollingJob.Stop();

        _trackLimit = value;
        _recentTracks.Clear();

        if (shouldResumePolling)
            _recentTracksPollingJob.Run();
    }

    private async Task HandleRefreshClickAsync()
    {
        var isFirstRequest = !_recentTracksPollingJob.IsStarted;
        _recentTracksPollingJob.Stop();

        _errorMessage = null;
        _username = InsertedUsername;

        if (_username.IsNullOrEmpty())
        {
            _errorMessage = "Username is required.";
            _recentTracks.Clear();

            return;
        }

        if (isFirstRequest)
        {
            _recentTracksFirstRequestCancellationTokenSource ??= new CancellationTokenSource();

            await _httpClient.SendRequestAsync<RecentTracksModel>(GetRecentTracksRequestMessage,
                successCallback: model =>
                {
                    _isRecentTracksFirstRequestSuccessful = true;
                    _recentTracks = model.Tracks.ToList();
                    _recentTracksPollingJob.Run();
                },
                failureCallback: message =>
                {
                    _isRecentTracksFirstRequestSuccessful = false;
                    _errorMessage = message;
                },
                finallyCallback: StateHasChanged,
                _recentTracksFirstRequestCancellationTokenSource.Token);
        }
        else
            _recentTracksPollingJob.Run();
    }

    private HttpRequestMessage GetRecentTracksRequestMessage()
    {
        var mostRecentTrackScrobbledAt = _recentTracks.FirstOrDefault(t => !t.IsPlayingNow)?.ScrobbledAt;

        return _musmetaniacApiRequestMessageProvider.GetRecentTracksRequestMessage(_username, _trackLimit, from: mostRecentTrackScrobbledAt?.AddSeconds(1));
    }

    private void CancelRecentTracksFirstRequestAndDisposeTokenSource()
    {
        _recentTracksFirstRequestCancellationTokenSource?.Cancel();
        _recentTracksFirstRequestCancellationTokenSource?.Dispose();
        _recentTracksFirstRequestCancellationTokenSource = null;
    }
}
