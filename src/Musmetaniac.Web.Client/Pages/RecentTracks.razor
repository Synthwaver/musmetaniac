@using Musmetaniac.Web.Common.Models

@page "/recenttracks"

@implements IDisposable

@inject IPollingHelper _pollingHelper
@inject IMusmetaniacApiRequestMessageProvider _musmetaniacApiRequestMessageProvider
@inject NavigationManager _navigation

<PageTitle>Recent tracks</PageTitle>

<Card>
    <TitleTemplate>
        <Title Level="3">Recent Tracks</Title>
    </TitleTemplate>
    <Body>
        <Space Direction="DirectionVHType.Vertical" Style="display: unset;">
            <SpaceItem style="display: flex; gap: 5px;">
                <Input Id="username" Placeholder="Username" @bind-Value="@InsertedUsername" Size="@InputSize.Large" AllowClear />
                <Button Type="@ButtonType.Primary" Icon="@IconType.Outline.ArrowRight" OnClick="@HandleUpdateClick" Size="@InputSize.Large"></Button>
            </SpaceItem>
            @if (!_errorMessage.IsNullOrEmpty())
            {
                <SpaceItem>
                    <Alert Message="@_errorMessage" Type="@AlertType.Error" />
                </SpaceItem>
            }
            <SpaceItem>
                Limit
                <Select
                    TItem="int"
                    TItemValue="int"
                    DataSource="new[] { 5, 10, 15 }"
                    Value="@_trackLimit"
                    ValueChanged="v => HandleLimitChange(v)"
                    Size="@InputSize.Small"
                    Style="width: 60px;"
                >
                </Select>
            </SpaceItem>
        </Space>
    </Body>
</Card>

@if (_recentTracks.Count != 0)
{
    <Title Level="4" Style="margin-top: 20px; margin-bottom: 20px;">
        Recent Tracks for <Text Code>@_username</Text>
    </Title>
    @foreach (var track in _recentTracks.Take(_trackLimit))
    {
        <RecentTrack Track="@track" />
    }
}

@code {
    private readonly TimeSpan _pollingPeriod = TimeSpan.FromSeconds(5);

    private List<RecentTracksModel.Track> _recentTracks = new();
    private PollingJob<RecentTracksModel> _recentTracksPollingJob = null!;

    private string _insertedUsername = "";
    private string _username = "";
    private int _trackLimit = 5;
    private string? _errorMessage;

    [Parameter]
    [SupplyParameterFromQuery(Name = "username")]
    public string InsertedUsername
    {
        get => _insertedUsername;
        set
        {
            if (_insertedUsername == value)
                return;

            _insertedUsername = value;
            _navigation.UpdateQueryParameter("username", value);
        }
    }

    public void Dispose()
    {
        _recentTracksPollingJob.Dispose();
        GC.SuppressFinalize(this);
    }

    protected override void OnInitialized()
    {
        _recentTracksPollingJob = _pollingHelper.CreatePollingJob(GetRecentTracksRequestMessage, new PollingJobOptions<RecentTracksModel>
        {
            SuccessCallback = model =>
            {
                // The track playing now is temporary and is updated with each request.
                // Since it may stop playing and disappear from the list, we always store one more track
                // to display tracks according to the selected limit.
                _recentTracks.RemoveAll(t => t.IsPlayingNow);
                _recentTracks = model.Tracks.Concat(_recentTracks).Take(_trackLimit + 1).ToList();
            },
            FailureCallback = message => _errorMessage = message,
            FinallyCallback = StateHasChanged,
            PollingPeriod = _pollingPeriod,
            StopOnFail = true,
        });

        HttpRequestMessage GetRecentTracksRequestMessage()
        {
            var mostRecentTrackScrobbledAt = _recentTracks.FirstOrDefault(t => !t.IsPlayingNow)?.ScrobbledAt;

            return _musmetaniacApiRequestMessageProvider.GetRecentTracksRequestMessage(_username, _trackLimit, from: mostRecentTrackScrobbledAt?.AddSeconds(1));
        }
    }

    private void HandleLimitChange(int value)
    {
        var shouldResumePolling = _recentTracksPollingJob.IsStarted;
        _recentTracksPollingJob.Stop();

        _trackLimit = value;
        _recentTracks.Clear();

        if (shouldResumePolling)
            _recentTracksPollingJob.Run();
    }

    private void HandleUpdateClick()
    {
        _recentTracksPollingJob.Stop();
        _errorMessage = null;
        _username = InsertedUsername;

        if (_username.IsNullOrEmpty())
        {
            _errorMessage = "Username is required.";
            _recentTracks.Clear();

            return;
        }

        _recentTracksPollingJob.Run();
    }
}
